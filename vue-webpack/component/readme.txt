Vue
  编程范式:
   1. 命令式: 第一步 获取数据, 第二步 赋值, 第三步 展示...
   2. 声明式: vue, 声明绑定关系即可, 数据与视图自动关联

组件化是 Vue.js 中的重要思想
 1. 它提供了一种抽象, 让我们可以开发出一个个独立可复用的小组件来构造我们的应用;
 2. 任何的应用都会被抽象成一颗组件树


组件的使用:
1. 创建组件构造器
    调用 Vue.extend() 方法创建组件构造器
2. 注册组件
    调用 Vue.component() 方法注册组件
3. 使用组件
    在 Vue 实例的作用范围内使用组件

全局组件: 可以在任意 Vue 实例下使用
局部组件: 只能在指定 Vue 实例下使用

组件无法访问 Vue 实例数据(顶层 Vue 实例的 data 无法被组件访问).
另, 即使可以访问, 如果把所有数据放在 顶层 Vue 实例, Vue 实例 data 域将会变得非常臃肿
组件是一个单独功能模块的封装:
    模块有属于自己的 HTML 模板, 也应该有自己的 data
    组件的 data 类型必须为 function 类型, 该函数必须返回一个对象, 内部保存着数据
    组件也有 methods 属性

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
组件选项
传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例： data 和 el。
试想如果我们简单地把一个对象作为 data 选项传给 Vue.extend()：

var data = { a: 1 }
var MyComponent = Vue.extend({
  data: data
})

这么做的问题是 MyComponent 所有的实例将共享同一个 data 对象！这基本不是我们想要的，
因此我们应当使用一个函数作为 data 选项，让这个函数返回一个新对象：

var MyComponent = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
同理，el 选项用在 Vue.extend() 中时也须是一个函数。

--------------------------------------------------------------------------------------------------------
模板解析
Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。
相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是有效的 HTML 片段。
一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：

a 不能包含其它的交互元素（如按钮，链接）
ul 和 ol 只能直接包含 li
select 只能包含 option 和 optgroup
table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup
tr 只能直接包含 th 和 td
在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果。
例如 <my-select><option>...</option></my-select> 不是有效的模板，即使 my-select 组件最终展开为 <select>...</select>。

另一个结果是，自定义标签（包括自定义元素和特殊标签，如 <component>、<template>、 <partial> ）
不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面，因而渲染不正确。

对于自定义元素，应当使用 is 特性：

<table>
  <tr is="my-component"></tr>
</table>
<template> 不能用在 <table> 内，这时应使用 <tbody>，<table> 可以有多个 <tbody>：

<table>
  <tbody v-for="item in items">
    <tr>Even row</tr>
    <tr>Odd row</tr>
  </tbody>
</table>
--------------------------------------------------------------------------------------------------------


一般而言: 网络请求由最外层的组件发送, 并由最外层的组件接收到数据之后, 将各个子组件需要的数据传递下去.
此即, 由父组件到子组件的通信.

!!!父子组件的通信
   子组件无法直接访问父组件或者 Vue 实例的数据.
   但是, 在开发中, 往往一些数据确实需要从上层传递到下层:
     比如, 一个页面中, 从服务器请求到了很多的数据, 其中一部分数据, 并非是整个页面的父组件
     来展示, 而是需要下面的子组件进行处理展示, 这时, 并不会让子组件单独发送网络请求, 而是
     直接让 父组件 将数据传递给 子组件.
  通信方式:
   1. 通过 props 向 子组件 传递数据
      props 的值有两种方式:
        1.1. 字符串数组, 数组中的字符串就是传递时的名称;
        1.2. 对象, 对象可以设置传递时的类型, 也可以设置默认值等
           验证支持的数据类型: String, Number, Boolean, Array, Object, Date, Function, Symbol
           另, 有自定义构造函数时, 也支持自定义的类型验证
   2. 通过 事件 向 父组件 发送消息


!!!双向绑定禁止绑定 props 属性(父传子的属性)!!!
在子组件中通过双向绑定修改父组件属性值.html
不要直接在子组件中修改父组件的属性值.html


父子通信
 1. 都是通过子组件的某个部分
 2. 父到子-属性: 通过 子组件的属性 -- props
 3. 子到父-事件: 通过 子组件的自定义事件 -- 在子组件通过 this.$emit 定义事件并在子组件的方法中
    通过浏览器固有事件-如 input 事件等 激活.


组件: 提高复用性
slot: 插槽, 提高组件的可扩展性, 自定义性

Vue 官方: 父组件模板的所有东西都会在父级作用域内编译; 子组件模板的所有东西都会在子级作用域内编译.
作用域 slot: 父组件替换 slot 的标签, 但是内容由子组件来提供


--------------------------------------------------------------------------------------------------------

字面量语法 vs. 动态语法
初学者常犯的一个错误是使用字面量语法传递数值：

<!-- 传递了一个字符串 "1" -->
<comp some-prop="1"></comp>
因为它是一个字面 prop，它的值以字符串 "1" 而不是以实际的数字传下去。
如果想传递一个实际的 JavaScript 数字，需要使用动态语法，从而让它的值被当作 JavaScript 表达式计算：

<!-- 传递实际的数字  -->
<comp :some-prop="1"></comp>

--------------------------------------------------------------------------------------------------------
编写可复用组件
在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。
Vue.js 组件 API 来自三部分 —— prop, 事件和 slot：
prop 允许外部环境传递数据给组件；
事件 允许组件触发外部环境的 action；
slot 允许外部环境插入内容到组件的视图结构内。

使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：

<my-component
  :foo="baz" // v-bind  --props
  :bar="qux"
  @event-a="doThis" // v-on -- event
  @event-b="doThat">
  <!-- content -->
  <img slot="icon" src="...">
  <p slot="main-text">Hello!</p>  // 具名插槽--slot
</my-component>

--------------------------------------------------------------------------------------------------------
解析 DOM 模板时的注意事项
有些 HTML 元素，诸如 <ul>、<ol>、<table> 和 <select>，对于哪些元素可以出现在其内部是有严格限制的。
而有些元素，诸如 <li>、<tr> 和 <option>，只能出现在其它某些特定的元素内部。

这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：

<table>
  <blog-post-row></blog-post-row>
</table>
这个自定义组件 <blog-post-row> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：

<table>
  <tr is="blog-post-row"></tr>
</table>
需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：

字符串 (例如：template: '...')
单文件组件 (.vue)
<script type="text/x-template">
--------------------------------------------------------------------------------------------------------

